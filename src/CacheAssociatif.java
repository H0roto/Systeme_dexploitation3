import java.io.*;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.Map;

public class CacheAssociatif extends LinkedHashMap<Integer,Integer> {
    static int TEMPS_ACCES_RAM = 50;
    static int TEMPS_ACCES_CACHE = 5;
    static int TAILLE_BLOC = 32;
    static int DEPLACEMENT = 5;
    Map<Integer, LinkedList<Integer>> cache;
    int nbSucces;
    int nbEchec;
    int nbEntree;
    double tempsMoyen;
    int nbbit;
    final int taille_cache;

    public CacheAssociatif(int n,String fichier,int nbE) {
        this.nbEntree=nbE;
        this.taille_cache = (int) Math.pow(2, n);
        this.cache = new LinkedHashMap<>();
        this.nbbit = n;
        try {
            File file = new File("src/tp1-fichiers-fournis/"+fichier);
            FileReader fr = new FileReader(file);
            BufferedReader br = new BufferedReader(fr);

            String line;
            while ((line = br.readLine()) != null) {
                String[] parts = line.split(":");
                if (parts.length == 2) {
                    Integer adresse = Integer.parseInt(parts[0]);
                    //System.out.println(adresse);
                    int deplacement = adresse & (TAILLE_BLOC - 1);
                    int noligne = (adresse >> DEPLACEMENT) & ((1 << this.nbbit) - 1);
                    int etiquette = adresse >> (DEPLACEMENT + this.nbbit);
                    this.addToCache(noligne, etiquette);
                    String acces = parts[1];
                } else {
                    System.out.println("Format de ligne non valide: " + line);
                }
            }
            br.close();
            System.out.println("Nombre de succès: "+this.nbSucces);
            System.out.println("Nombre d'échecs: "+this.nbEchec);
            this.tempsMoyen=(double)(this.nbSucces*TEMPS_ACCES_CACHE+this.nbEchec*TEMPS_ACCES_RAM)/(this.nbSucces+this.nbEchec);
            System.out.println("Temps moyen: "+Math.round(this.tempsMoyen * 100.0) / 100.0+" ns");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    public void addToCache(int key, int value) {
        LinkedList<Integer> values = cache.computeIfAbsent(key, k -> new LinkedList<>());

        // Si la valeur existe déjà, la supprimer pour la réajouter (mise à jour LRU)
        if (values.contains(value)) {
            this.nbSucces+=1;
            values.remove(Integer.valueOf(value));
        }
        else{
            this.nbEchec+=1;
        }
        values.add(value); // Ajoute à la fin (la plus récemment utilisée)

        // Supprime l'élément le plus ancien si la taille dépasse la limite
        if (values.size() > nbEntree) {
            int i=values.removeFirst();
        }
    }

    public static void main(String[] args) {
        double min=Integer.MAX_VALUE;
        int indminN=-1;
        int indminE=-1;
        for(int j=2;j<5;j+=2){
            for (int i = 2; i < 8; i++) {
                System.out.println("Pour n égal à: " + i+" Et nbEntrée égal à: "+j);
                CacheAssociatif cd = new CacheAssociatif(i,"matrice10.txt",j);
                if (cd.tempsMoyen < min) {
                    min = cd.tempsMoyen;
                    indminN = i;
                    indminE=j;
                }
            }
        }
        System.out.println("La meilleure valeur de n est: "+indminN+" Et nbEntrée est :"+indminE);
        //On voit que pour le coup, il n'y a pas besoin d'avoir un grand nombre d'entrée pour accueillir les données de ce fichier

        min=Integer.MAX_VALUE;
        indminN=-1;
        indminE=-1;
        for(int j=2;j<5;j+=2){
            for (int i = 7; i < 9; i++) {
                System.out.println("Pour n égal à: " + i+" Et nbEntrée égal à: "+j);
                CacheAssociatif cd = new CacheAssociatif(i,"matrice100.txt",j);
                if (cd.tempsMoyen < min) {
                    min = cd.tempsMoyen;
                    indminN = i;
                    indminE=j;
                }
            }
        }
        System.out.println("La meilleure valeur de n est: "+indminN+" Et nbEntrée est :"+indminE);
        //Pour un grand nombre de nonnées, augmenter le nombre d'entrée est une bonne idée ainsi que la taille du cache,
        //Puisque les valeurs optimales sont les plus élevées ici .
    }
}
